{}
  :idx |022
  :title "|锁版本问题"
  :messages $ []
    {}
      :author |Bot
      :text "|(2019年某一天)"

    {}
      :author "|引证"
      :text "|[捂脸]前两天，天猪在你的群里，因为锁版本的事情和别人战了一个下午"
    {}
      :author "|天猪"
      :text "|不算战吧，就是阐述下锁并不是一劳永逸，然后提出几个场景，让他们思考锁了之后如何处理这些场景而已"
    {}
      :author "|justjavac(迷渡)"
      :text "|其实我觉得，应该搞明白锁的利弊，以及不锁的利弊，自己权衡就行了"
    {}
      :author "|justjavac(迷渡)"
      :text "|非要争个对错没有意义"
    {}
      :author "|天猪"
      :text "|是的，不同的技术背景和基建，不同的应急能力，风险处理能力，选择是不同的"
    {}
      :author "|敖天羽"
      :text "|又撕逼锁版本？？"
    {}
      :author "|敖天羽"
      :text "|每次你们说这个我都不敢说话= ="
    {}
      :author "|敖天羽"
      :text "|搞不懂有什么好撕逼的……"
    {}
      :author "|芋头"
      :text "|开发自己把控吧"
    {}
      :author "|芋头"
      :text "|可以根据厂里的情况给一个指导"
    {}
      :author "|芋头"
      :text "|不信任就锁，信任最好不锁"
    {}
      :author "|天猪"
      :text "|真不算撕吧，那天好像是 @引证 把我 @ 出来的，我后面就提了一个思考题而已：（只考虑 Node 场景） 对于锁版本的业务，如果当前使用的版本是 1.2.0，然后最新版本是 1.5.0。 此时距离业务的定时升级时间还有一周（嗯，这个团队很上进很积极） 现在出了一个严重的安全隐患 bug，发布了 1.5.1 修复，必须小时级别修复所有在线业务。"
    {}
      :author "|天猪"
      :text "|这时候，是发布一个 1.2.1 呢，还是升级 1.5.1 呢？ 升级 1.5.1 的话，意味着需要回归那些新的 feature，这个的耗时达不到小时级别。 如果 A 业务用了 1.2.0，B 业务用了 1.3.0，C 业务用了 1.4.0，然后是要发布 1.2.1，1.3.1，1.4.1，1.5.1 吗？ 如果这个模块的修复，依赖于另一个模块的某个早已经发布的版本（但业务还没升级这个版本）"
    {}
      :author "|天猪"
      :text "|这些场景都是现实存在的，锁版本和不锁版本的出发点都是优先解决某一类，然后其他措施来解决剩余的，没有银弹。 提这个场景主要是看很多支持锁版本的，都没考虑到这种场景，觉得锁是万能的。"
    {}
      :author "|Hax"
      :text "|锁版本的策略只能用于应用，而不能用于被其他人依赖的库，否则就产生版本升级传染。。。"
    {}
      :author "|天猪"
      :text "|上面那个场景就是说应用锁了版本后，遇到类库紧急升级，要怎么处理"
    {}
      :author "|justjavac(迷渡)"
      :text "|npm 默认的策略就是锁应用，npm pkg 的 lock 文件也只有在被安装之后根据应用的策略解析"
    {}
      :author "|Hax"
      :text "|@天猪 看上去就只能发布一系列的安全补丁版"
    {}
      :author "|justjavac(迷渡)"
      :text "|和贺老一样，我们现在的做法就是发布多个布丁版本"
    {}
      :author "|Hax"
      :text "|npm策略以前是不锁，改成默认锁应该是受到了yarn的胁迫。"
    {}
      :author "|小爝"
      :text "|最好的办法就是把node_modules也扔到仓库里 需要分钟级修复的bug 先把vendor改了再说"
    {}
      :author "|小爝"
      :text "|[捂脸]"
    {}
      :author "|小爝"
      :text "|就是那种回滚也解决不了的问题"
    {}
      :author "|justjavac(迷渡)"
      :text "|[捂脸]"
    {}
      :author "|小爝"
      :text "|😂"
    {}
      :author "|justjavac(迷渡)"
      :text "|以前真这么干过"
    {}
      :author "|小爝"
      :text "|没办法呀 [捂脸]"
    {}
      :author "|天猪"
      :text "|@Hax 从框架维护者的角度来看，也许一个包已经发布一年了，这时候要每一个版本发布，碎片化，很难维护的"
    {}
      :author "|小爝"
      :text "|还有一个办法 就是别写版本号了 都用yarn 写git#hash"
    {}
      :author "|天猪"
      :text "|没有银弹，不同出身不同的预案，不同取舍，就是抛出来个思考题。"
    {}
      :author "|小爝"
      :text "|😂改完改hash 赶紧修"
    {}
      :author "|Hax"
      :text "|是的。我其实不喜欢锁版本。锁版本的前提是你有比较好的维护。"
    {}
      :author "|Hax"
      :text "|如果维护能力一般，还不如不要锁，随（社区）波逐（大）流"
    {}
      :author "|天猪"
      :text "|锁版本的情况下，基本上很难应用治理了"
    {}
      :author "|justjavac(迷渡)"
      :text "|npm 的依赖链路太长，pkg 碎片化"
    {}
      :author "|天猪"
      :text "|上游依赖出问题，我们有快速止血方案，如 dist-tag 之类的，cnpm/bug-versions"
    {}
      :author "|Hax"
      :text "|我认为说，你需要把这个理念再推广一下，光写中文的不够，还要写个英文的。"
    {}
      :author "|天猪"
      :text "|[奸笑] 懒得。。。后面 serviceless 化后，没这么多事了"
    {}
      :author "|天猪"
      :text "|serverless"
    {}
      :author "|小爝"
      :text "|羡慕[捂脸]"
    {}
      :author "|Hax"
      :text "|serverless为啥就没锁版本问题？？"
    {}
      :author "|天猪"
      :text "|交付的是 runtime，不是 npm，问题会减轻很多"
    {}
      :author "|小爝"
      :text "|runtime没办法 给你啥用啥"
    {}
      :author "|天猪"
      :text "|还是会存在的，只是强管控后，减轻了不少"
    {}
      :author "|小爝"
      :text "|你也不知道什么版本"
    {}
      :author "|天猪"
      :text "|runtime 还解决了一个问题，就是次级依赖在测试环境没问题，预发的时候就升级了。runtime 相当于维护者级别的锁版本了，中心化的锁版本"

    {}
      :author "|Bot"
      :text "|(播放完成)"
